<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>공부 스톱워치</title>

  <style>
    :root { color-scheme: dark; }

    body {
      margin: 0;
      min-height: 100vh;
      display: grid;
      place-items: center;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial, sans-serif;
      background: #0b0f19;
      color: #f9fafb;
    }

    .card {
      width: min(720px, 94vw);
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 20px;
      padding: 22px;
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.35);
      backdrop-filter: blur(10px);
    }

    .top {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
      margin-bottom: 10px;
    }

    h1 {
      margin: 0;
      font-size: 18px;
      color: #f9fafb;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: #d1d5db;
      font-size: 12px;
      white-space: nowrap;
    }

    .time {
      font-variant-numeric: tabular-nums;
      font-size: 56px;
      letter-spacing: 1px;
      text-align: center;
      margin: 14px 0 8px;
      color: #ffffff;
      text-shadow: 0 0 12px rgba(255, 255, 255, 0.15);
    }

    .sub {
      text-align: center;
      font-size: 13px;
      margin-bottom: 14px;
      color: #d1d5db;
    }

    .row {
      display: flex;
      justify-content: center;
      gap: 10px;
      flex-wrap: wrap;
      margin-bottom: 12px;
    }

    button {
      padding: 12px 18px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.18);
      background: rgba(255, 255, 255, 0.08);
      color: #ffffff;
      cursor: pointer;
      font-size: 14px;
    }

    button.primary {
      background: rgba(34, 197, 94, 0.25);
      border-color: rgba(34, 197, 94, 0.45);
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
      margin-top: 10px;
    }

    .stat {
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.18);
      border-radius: 16px;
      padding: 12px;
    }

    .stat .label {
      color: #9ca3af;
      font-size: 12px;
      margin-bottom: 6px;
    }

    .stat .value {
      font-variant-numeric: tabular-nums;
      font-size: 18px;
      color: #ffffff;
    }

    .lists {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
      margin-top: 10px;
    }

    .panel {
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.18);
      border-radius: 16px;
      padding: 12px;
    }

    .panel h2 {
      margin: 0 0 8px;
      font-size: 13px;
      color: #e5e7eb;
      font-weight: 600;
    }

    .item {
      display: flex;
      justify-content: space-between;
      gap: 12px;
      padding: 8px 0;
      border-top: 1px solid rgba(255,255,255,0.08);
      font-variant-numeric: tabular-nums;
    }
    .item:first-of-type { border-top: none; }

    .item .k { color: #d1d5db; font-size: 13px; }
    .item .v { color: #ffffff; font-size: 13px; }

    .hint {
      margin-top: 12px;
      text-align: center;
      font-size: 13px;
      color: #9ca3af;
    }

    code { color: #e5e7eb; }

    @media (max-width: 640px) {
      .stats, .lists { grid-template-columns: 1fr; }
      .time { font-size: 50px; }
    }
  </style>
</head>

<body>
  <div class="card">
    <div class="top">
      <h1>공부 스톱워치 (누적 + 일/월 기록)</h1>
      <div id="autoSavePill" class="pill">자동 저장됨</div>
    </div>

    <div id="display" class="time">00:00:00</div>
    <div id="status" class="sub">정지됨 · 자동 저장됨</div>

    <div class="row">
      <button id="startPause" class="primary">시작</button>
    </div>

    <div class="stats">
      <div class="stat">
        <div class="label">오늘 누적</div>
        <div id="todayTotal" class="value">00:00:00</div>
      </div>
      <div class="stat">
        <div class="label">이번 달 누적</div>
        <div id="monthTotal" class="value">00:00:00</div>
      </div>
    </div>

    <div class="lists">
      <div class="panel">
        <h2>최근 7일</h2>
        <div id="dailyList"></div>
      </div>
      <div class="panel">
        <h2>최근 6개월</h2>
        <div id="monthlyList"></div>
      </div>
    </div>

    <div class="hint">
      단축키: <code>Space</code> 시작/일시정지 · 초기화 기능 없음
    </div>
  </div>

  <script>
    const $ = (id) => document.getElementById(id);

    const display = $("display");
    const statusEl = $("status");
    const startPauseBtn = $("startPause");
    const todayTotalEl = $("todayTotal");
    const monthTotalEl = $("monthTotal");
    const dailyListEl = $("dailyList");
    const monthlyListEl = $("monthlyList");

    const STORAGE_KEY = "study_stopwatch_v2";

    // 전체 누적(ms)
    let accumulatedMs = 0;

    // 실행 상태
    let running = false;

    // "실행 시작" 기준(밀리초 epoch)
    let startEpochMs = null;

    // 기록 분배를 위한 마지막 업데이트 시점(epoch ms)
    let lastUpdateEpochMs = null;

    // 일/월 기록
    // daily: { "YYYY-MM-DD": ms }
    // monthly: { "YYYY-MM": ms }
    let daily = {};
    let monthly = {};

    // 렌더 타이머
    let tickId = null;

    // ===== 날짜 키 유틸 (로컬 기준) =====
    function pad2(n) { return String(n).padStart(2, "0"); }

    function keyDayFromEpoch(epochMs) {
      const d = new Date(epochMs);
      const y = d.getFullYear();
      const m = pad2(d.getMonth() + 1);
      const da = pad2(d.getDate());
      return `${y}-${m}-${da}`;
    }

    function keyMonthFromEpoch(epochMs) {
      const d = new Date(epochMs);
      const y = d.getFullYear();
      const m = pad2(d.getMonth() + 1);
      return `${y}-${m}`;
    }

    function startOfNextDayEpoch(epochMs) {
      const d = new Date(epochMs);
      return new Date(d.getFullYear(), d.getMonth(), d.getDate() + 1, 0, 0, 0, 0).getTime();
    }

    // ===== 시간 포맷 =====
    function formatHMS(ms) {
      const totalSeconds = Math.floor(ms / 1000);
      const s = totalSeconds % 60;
      const totalMinutes = Math.floor(totalSeconds / 60);
      const mi = totalMinutes % 60;
      const h = Math.floor(totalMinutes / 60);
      return `${String(h).padStart(2,"0")}:${String(mi).padStart(2,"0")}:${String(s).padStart(2,"0")}`;
    }

    // ===== 저장/로드 =====
    function save() {
      const data = {
        accumulatedMs,
        running,
        startEpochMs,
        lastUpdateEpochMs,
        daily,
        monthly
      };
      localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
    }

    function load() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return;
        const data = JSON.parse(raw);

        if (typeof data.accumulatedMs === "number") accumulatedMs = data.accumulatedMs;
        if (typeof data.running === "boolean") running = data.running;
        if (typeof data.startEpochMs === "number") startEpochMs = data.startEpochMs;
        if (typeof data.lastUpdateEpochMs === "number") lastUpdateEpochMs = data.lastUpdateEpochMs;

        if (data.daily && typeof data.daily === "object") daily = data.daily;
        if (data.monthly && typeof data.monthly === "object") monthly = data.monthly;
      } catch {
        // 무시
      }
    }

    // ===== 시간 분배 로직 (자정 넘어도 정확히 기록) =====
    function addMsToMaps(dayKey, monthKey, ms) {
      if (ms <= 0) return;
      daily[dayKey] = (daily[dayKey] || 0) + ms;
      monthly[monthKey] = (monthly[monthKey] || 0) + ms;
    }

    function distributeInterval(startMs, endMs) {
      // [startMs, endMs) 구간의 시간을 날짜 경계(자정) 기준으로 쪼개서 daily/monthly에 더함
      let cur = startMs;
      while (cur < endMs) {
        const dayKey = keyDayFromEpoch(cur);
        const monthKey = keyMonthFromEpoch(cur);
        const nextDay = startOfNextDayEpoch(cur);
        const sliceEnd = Math.min(endMs, nextDay);
        addMsToMaps(dayKey, monthKey, sliceEnd - cur);
        cur = sliceEnd;
      }
    }

    // 실행 중이면 "지난 업데이트 이후" 경과를 누적 및 기록에 반영
    function applyDeltaToTotalsAndRecords() {
      if (!running) return;
      const now = Date.now();
      if (!lastUpdateEpochMs) lastUpdateEpochMs = now;

      const start = lastUpdateEpochMs;
      const end = now;
      if (end <= start) return;

      const delta = end - start;
      accumulatedMs += delta;
      distributeInterval(start, end);

      lastUpdateEpochMs = now;
      save();
    }

    // ===== 현재 누적(ms) =====
    function currentMs() {
      // 실시간 표시를 위해 "applyDelta..."를 이미 반영했다고 가정하고 accumulatedMs를 쓰는 방식
      // (렌더 루프에서 applyDeltaToTotalsAndRecords() 호출)
      return accumulatedMs;
    }

    // ===== UI 렌더 =====
    function renderLists() {
      // 오늘/이번달 키
      const now = Date.now();
      const todayKey = keyDayFromEpoch(now);
      const monthKey = keyMonthFromEpoch(now);

      const todayMs = daily[todayKey] || 0;
      const monthMs = monthly[monthKey] || 0;

      todayTotalEl.textContent = formatHMS(todayMs);
      monthTotalEl.textContent = formatHMS(monthMs);

      // 최근 7일 (오늘 포함)
      const dailyItems = [];
      {
        const d = new Date();
        d.setHours(0,0,0,0);
        for (let i = 0; i < 7; i++) {
          const dayEpoch = d.getTime() - i * 24 * 60 * 60 * 1000;
          const k = keyDayFromEpoch(dayEpoch);
          dailyItems.push([k, daily[k] || 0]);
        }
      }
      dailyListEl.innerHTML = dailyItems
        .map(([k, ms]) => {
          // 표시를 YYYY-MM-DD → MM/DD로 가볍게
          const mmdd = k.slice(5).replace("-", "/");
          return `<div class="item"><div class="k">${mmdd}</div><div class="v">${formatHMS(ms)}</div></div>`;
        })
        .join("");

      // 최근 6개월 (이번달 포함)
      const monthlyItems = [];
      {
        const d = new Date();
        d.setDate(1);
        d.setHours(0,0,0,0);
        for (let i = 0; i < 6; i++) {
          const md = new Date(d.getFullYear(), d.getMonth() - i, 1, 0, 0, 0, 0);
          const k = keyMonthFromEpoch(md.getTime());
          monthlyItems.push([k, monthly[k] || 0]);
        }
      }
      monthlyListEl.innerHTML = monthlyItems
        .map(([k, ms]) => {
          // YYYY-MM → YYYY.MM
          const label = k.replace("-", ".");
          return `<div class="item"><div class="k">${label}</div><div class="v">${formatHMS(ms)}</div></div>`;
        })
        .join("");
    }

    function render() {
      display.textContent = formatHMS(currentMs());
      document.title = running ? `⏱️ ${formatHMS(currentMs())}` : `공부 스톱워치 - ${formatHMS(currentMs())}`;
      statusEl.textContent = (running ? "측정 중" : "정지됨") + " · 자동 저장됨";
      startPauseBtn.textContent = running ? "일시정지" : "시작";
      renderLists();
    }

    // ===== 동작 제어 =====
    function start() {
      if (running) return;
      running = true;
      const now = Date.now();
      startEpochMs = now;
      lastUpdateEpochMs = now; // 분배 기준 시작
      save();
      if (tickId) clearInterval(tickId);
      tickId = setInterval(() => {
        applyDeltaToTotalsAndRecords();
        render();
      }, 250);
      render();
    }

    function pause() {
      if (!running) return;
      // 멈추기 직전까지 반영
      applyDeltaToTotalsAndRecords();

      running = false;
      startEpochMs = null;
      lastUpdateEpochMs = null;
      save();

      if (tickId) clearInterval(tickId);
      tickId = null;
      render();
    }

    function toggle() {
      running ? pause() : start();
    }

    // ===== 이벤트 =====
    startPauseBtn.addEventListener("click", toggle);

    window.addEventListener("keydown", (e) => {
      if (e.code === "Space") {
        e.preventDefault();
        toggle();
      }
    });

    window.addEventListener("beforeunload", () => {
      // 닫히기 직전 실행 중이면 마지막 반영 후 저장
      if (running) applyDeltaToTotalsAndRecords();
      save();
    });

    // ===== 초기화(로드) 처리 =====
    load();

    // 만약 실행 중 상태로 저장되어 있었다면, "꺼져있던 동안" 경과도 반영해야 함
    if (running && typeof startEpochMs === "number") {
      // lastUpdateEpochMs가 있으면 그 시점부터 now까지 분배
      const now = Date.now();
      const startForCatchup = (typeof lastUpdateEpochMs === "number") ? lastUpdateEpochMs : startEpochMs;
      distributeInterval(startForCatchup, now);
      accumulatedMs += Math.max(0, now - startForCatchup);

      // 계속 실행 상태 유지
      lastUpdateEpochMs = now;
      startEpochMs = now;
      save();

      tickId = setInterval(() => {
        applyDeltaToTotalsAndRecords();
        render();
      }, 250);
    }

    render();
  </script>
</body>
</html>
